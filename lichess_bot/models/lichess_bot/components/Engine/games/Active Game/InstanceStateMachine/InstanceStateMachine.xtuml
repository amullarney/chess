// BP 7.1.6 content: InstanceStateMachine syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine::games::'Active Game' is

  @state_num(1);
  @dialect("oal");
  state created;

  @state_num(3);
  @dialect("oal");
  state 'game over';

  @state_num(4);
  @dialect("oal");
  state 'our turn';

  @state_num(5);
  @dialect("oal");
  state 'their turn';

  @state_num(6);
  @dialect("oal");
  state 'playing move';

  @state_num(7);
  @dialect("oal");
  state 'claiming victory';

  @event_num(1);
  event 'waiting on move';

  @event_num(2);
  event 'game over'(status: in GameStatus);

  @event_num(3);
  event 'play move'(move: in string);

  @event_num(4);
  event 'ready to play';

  @event_num(5);
  event 'claim victory';

  state model is

    |                    | 'waiting on move'  | 'game over'        | 'play move'        | 'ready to play'    | 'claim victory'    |
    | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ |
    | created            | 'their turn'       | cannot_happen      | cannot_happen      | 'our turn'         | ignore             |
    | 'game over'        | ignore             | cannot_happen      | ignore             | ignore             | ignore             |
    | 'our turn'         | ignore             | 'game over'        | 'playing move'     | 'our turn'         | 'claiming victory' |
    | 'their turn'       | ignore             | 'game over'        | ignore             | 'our turn'         | 'claiming victory' |
    | 'playing move'     | 'their turn'       | 'game over'        | cannot_happen      | ignore             | 'claiming victory' |
    | 'claiming victory' | ignore             | 'game over'        | ignore             | ignore             | ignore             |

  end state model;

  state 'game over'(status: in GameStatus) is
    @noparse
    LOG::LogInfo(message:"Game: " + self.id + ": Game over!");
    r = TIM::timer_cancel(timer_inst_ref: self.claim_victory_timer);
    self.dispose();
    @endnoparse
  end state;

  state 'our turn' is
    @noparse
    // Attempt to model the thought process of a chess player:
    // Look for opponent pieces to attack.
    // Evaluate the possible cost of responses.
    // Evaluate own-side vulnerabilities.
    // Do the cost-benefit analysis; if undecided, do something.

    played_moves = self.game_state.moves;

    select one myplayer related by self->Player[R22.'is acting for'];
    select one opponent related by myplayer->Player[R8.'opposes'];

    i = played_moves.length;
    if (i > 0)
      // now update ground truth based on opponent's last move
      movestr = played_moves[i-1];  // most recent from opponent
      opponent_fromocsq = ::from_occupied( movestr:movestr );
      opponent_tosquare = ::to_square( movestr:movestr );
      ::record_move( from:opponent_fromocsq, to:opponent_tosquare, recorder:"player: " );
    end if;

    // ensure that Move instances match allowed moves
    select any nullinstance from instances of Move where false;
    ::reconcile_moves( fen:self.initial_fen, moves:played_moves, player:myplayer, trial_move:nullinstance );

    // now we have bona-fide set of legal Move instances find those that end on opponent squares
    target_moves = ::find_target_moves( player:myplayer );

    // evaluate the possible consequence of each such move - what might opponent capture?
    for each tgtmove in target_moves
      select one spec related by tgtmove->Square[R5.'targets']->OccupiedSquare[R1]->Piece[R2.'is occupied by']->PieceSpecification[R4.'is specified by'];
      tgtmove.Value = spec.Value;
      select one pm related by tgtmove->PotentialMove[R11];
      unrelate tgtmove from pm across R11;
      delete object instance pm;
      create object instance em of EvaluatingMove;
      relate tgtmove to em across R11;
      ::evaluate_response( move:tgtmove, fen:self.initial_fen, played_moves:played_moves );
      select one em related by tgtmove->EvaluatingMove[R11];
      unrelate tgtmove from em across R11;
      delete object instance em;
      create object instance pm of PotentialMove;
      relate tgtmove to pm across R11;
    end for;


    select any chosen_move from instances of Move where false;  // decl

    // select the move with the best trade-off - if there is one
    best = 0;
    select any attack_move from instances of Move where false;  // decl
    for each tgtmove in target_moves
      LOG::LogInfo( message:tgtmove.Notation + " has value " + STRING::itoa( i:tgtmove.Value ));
      if (tgtmove.Value > best)
        best = tgtmove.Value;
        attack_move = tgtmove;
      end if;
    end for;

    // consider vulnerablity avoidance
    escape_move = ::play_safe( opponent:opponent );

    // attack or flee?
    chosen_move = attack_move;
    if (not_empty attack_move) 
      chosen_move = attack_move;
      if (not_empty escape_move)
    	  if (escape_move.Value > attack_move.Value)
    	    chosen_move = escape_move;
    	  end if;
    	end if;
    else
      chosen_move = escape_move;
    end if;  

    if (empty chosen_move)  
      // if no move selected, may be opening stages of game; look for a move
      if (played_moves.length < 10)  // arbitrary limit on opening move search
        select many openermoves related by myplayer->Move[R6.'can play'];
        chosen_move = ::pick_opener_move( moves:openermoves );
        if (not_empty chosen_move)
          LOG::LogInfo(message: "BOT picked opening move: " + chosen_move.Notation);
        end if;
      end if;
    end if;

    // still no clear choice of move; time for some heuristic...
    if (empty chosen_move)
      if (not_empty target_moves)
    		for each move in target_moves
    		  if (move.Value > -2)  // in desperation, allow for minor loss
    		    chosen_move = move;
            LOG::LogInfo(message: "BOT picked sacrifice move: " + chosen_move.Notation);
    		    break;
    		  end if;
    		end for;
      end if;
    end if;

    // look for benign move
    if (empty chosen_move)
      select many mymoves related by myplayer->Move[R6.'can play'];
      select many reachables related by mymoves->Square[R5.'targets']->OpenSquare[R1];
      coveredsquares = ::find_covered_squares( player:opponent );
      refuges = reachables - coveredsquares;
      select many tomoves related by refuges->Square[R1]->Move[R5]; 
      escapemoves = mymoves & tomoves;
      for each escape in escapemoves
        select one sq related by escape->Square[R5.'targets'];
        LOG::LogInfo(message:"Random safe move to " + sq.lichess_desig);
        chosen_move = escape; 
        break;
      end for;
    end if;  

    // have to do something!
    if (empty chosen_move)
      select any chosen_move related by myplayer->Move[R6.'can play'];
      LOG::LogInfo(message: "BOT picked random move: " + chosen_move.Notation); // last resort!
    end if;

    select one piece related by chosen_move->Piece[R9.'is made by'];
    select one tosq related by chosen_move->Square[R5.'targets'];
    select one fromsq related by chosen_move->OccupiedSquare[R5.'vacates']->Square[R1];
    // play the move - in lichess notation
    ourmove = ::movestr( from:fromsq, to:tosq );

    // check legality - debug
    legal_moves = ChessLib::legalMoves(fen: ChessLib::movesToFEN(initialFen: self.initial_fen, moves: played_moves));
    nlegals = legal_moves.length;
    i = 0;
    found = false;
    while (i < nlegals)
      if (ourmove == legal_moves[i])
        found = true;
        break;
      end if;
      i = i + 1;
    end while;
    if (not found)
      LOG::LogFailure( message:"illegal move" );
    end if;
    if (tosq.rank == 1 or tosq.rank == 8)
      select one spec related by piece->PieceSpecification[R4.'is specified by'];
      if (spec.Name == "Pawn")
        ourmove = ourmove + "q";  // request promotion to Queen
      end if;
    end if;
    //LOG::LogInfo(message: "BOT selected: " + ourmove); 
    create event instance e of ActiveGame3:'play move'(move: ourmove) to self;
    // zero-timer prevents event prioritization by event-to-self acceleration.
    t = TIM::timer_start(event_inst:e, microseconds: 0);
    @endnoparse
  end state;

  state 'playing move'(move: in string) is
    @noparse
    movestr = param.move;

    // play the move
    //LOG::LogInfo( message:"BOT asking to play move: " + movestr );
    success = chess::move(game_id: self.id, move: movestr);
    if success then
      fromocsq = ::from_occupied( movestr:movestr );
      tosquare = ::to_square( movestr:movestr );
      if ( (empty fromocsq) or (empty tosquare) )
        LOG::LogInfo( message:"Problem with: " + movestr );
      end if;
      ::record_move( from:fromocsq, to:tosquare, recorder:" BOT: " );
    	generate ActiveGame1:'waiting on move' to self;
    else
      LOG::LogFailure(message: "Failed to make move.");
      create event instance e of ActiveGame4:'ready to play' to self;
      t = TIM::timer_start(event_inst: e, microseconds: 100000);  // short delay to slow down endless loop possibility
    end if;
    @endnoparse
  end state;

  state 'claiming victory' is
    @noparse
    r = chess::claimVictory(game_id: self.id);
    @endnoparse
  end state;

  transition 'their turn' ['ready to play'] => 'our turn' is
    @noparse
    // handle takeback proposals
    if (self.color == Color::WHITE and self.game_state.btakeback) or
      (self.color == Color::BLACK and self.game_state.wtakeback) then
      self.handle_takeback_proposal();
    end if;

    // handle draw offers
    if (self.color == Color::WHITE and self.game_state.bdraw) or
      (self.color == Color::BLACK and self.game_state.wdraw) then
      self.handle_draw_offer();
    end if;
    @endnoparse
  end transition;

end;
