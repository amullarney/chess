// BP 7.1.6 content: InstanceStateMachine syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine::games::'Active Game' is

  @state_num(1);
  @dialect("oal");
  state created;

  @state_num(3);
  @dialect("oal");
  state 'game over';

  @state_num(4);
  @dialect("oal");
  state 'our turn';

  @state_num(5);
  @dialect("oal");
  state 'their turn';

  @state_num(6);
  @dialect("oal");
  state 'playing move';

  @state_num(7);
  @dialect("oal");
  state 'claiming victory';

  @event_num(1);
  event 'waiting on move';

  @event_num(2);
  event 'game over'(status: in GameStatus);

  @event_num(3);
  event 'play move'(move: in string);

  @event_num(4);
  event 'ready to play';

  @event_num(5);
  event 'claim victory';

  state model is

    |                    | 'waiting on move'  | 'game over'        | 'play move'        | 'ready to play'    | 'claim victory'    |
    | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ |
    | created            | 'their turn'       | cannot_happen      | cannot_happen      | 'our turn'         | ignore             |
    | 'game over'        | ignore             | cannot_happen      | ignore             | ignore             | ignore             |
    | 'our turn'         | ignore             | 'game over'        | 'playing move'     | 'our turn'         | 'claiming victory' |
    | 'their turn'       | ignore             | 'game over'        | ignore             | 'our turn'         | 'claiming victory' |
    | 'playing move'     | 'their turn'       | 'game over'        | cannot_happen      | ignore             | 'claiming victory' |
    | 'claiming victory' | ignore             | 'game over'        | ignore             | ignore             | ignore             |

  end state model;

  state 'game over'(status: in GameStatus) is
    @noparse
    LOG::LogInfo(message:"Game: " + self.id + ": Game over!");
    r = TIM::timer_cancel(timer_inst_ref: self.claim_victory_timer);
    self.dispose();
    @endnoparse
  end state;

  state 'our turn' is
    @noparse
    // handle takeback proposals
    if (self.color == Color::WHITE and self.game_state.btakeback) or
    	(self.color == Color::BLACK and self.game_state.wtakeback) then
    	self.handle_takeback_proposal();
    end if;
    
    // handle draw offers
    if (self.color == Color::WHITE and self.game_state.bdraw) or
    	(self.color == Color::BLACK and self.game_state.wdraw) then
    	self.handle_draw_offer();
    end if;
    
    moves = self.game_state.moves;
    legal_moves = ChessLib::legalMoves(fen: ChessLib::movesToFEN(initialFen: self.initial_fen, moves: moves));
    
    ourmove = "";  // until we choose..
    
    i = moves.length;
      
    if (self.color == Color::WHITE)
      if (i == 0)  // first move? - open with King pawn.. or, TBD, pick an opening strategy
        ourmove = "e2e4";
      end if;
    end if;
    if (i > 0)
      move = moves[i-1];  // most recent from opponent
      ::record_move( move:move, from:" Player " );
    //  ourmove = Play::respond( move:move, legals: legal_moves );
    end if;
    
    
    // a simplistic attempt to choose a move based on high-value target.
    best = 0;
    n = legal_moves.length - 1;
    i = 0;
    
    select many pms from instances of ProspectiveMove
     where ( selected.Eval_depth == 1);
    for each pm in pms
      pm.Retain = false;
    end for;
    
    while (i < n)  // for each legal move we could play...
      select any pm from instances of ProspectiveMove
       where (selected.Notation == legal_moves[i]);
      if (empty pm) 
    	  create object instance pm of ProspectiveMove;
    	  pm.Eval_depth = 1;
    	  pm.Notation = legal_moves[i];  // keep this for debug - and for various moves arrays
    	  start = ::from_square( move:legal_moves[i] );
    	  target = ::to_square( move:legal_moves[i] );
    	  relate pm to start across R5.'vacates';
    	  relate pm to target across R6.'ends on';
    	  pm.Retain = true;
    	else
    	  pm.Retain = true;
      end if;
      i = i + 1;
    end while;
    
    select many pms from instances of ProspectiveMove
     where ( selected.Eval_depth == 1);
    for each pm in pms
      if (pm.Retain == false);
        pm.delete();
      end if;
    end for;
    
    select many oppieces from instances of OpponentPiece;
    select many sqs related by oppieces->Piece[R3]->OccupiedSquare[R2.'occupies']->Square[R1];
    select many pms from instances of ProspectiveMove;
    select many tgts related by pms->Square[R6.'ends on'];
    opsqs = tgts & sqs;
    
    for each opsq in opsqs
      select one spec related by opsq->OccupiedSquare[R1]->Piece[R2.'is occupied by']->PieceSpecification[R4.'is specified by'];
      // does this opportunity already exist?..
      // get target value from spec -- TBD
    end for;  
    /*
    select many possible_moves from instances of  ProspectiveMove
     where (selected.Eval_depth == 1);
    for each possible in possible_moves
      if (possible.Value > best)
        ourmove = possible.Notation;
        best = possible.Value;
      end if;
    end for; 
    */
    
    if (ourmove == "")
      select any move from instances of  ProspectiveMove
       where ( selected.Is_safe == true);
      if (not_empty move)
        ourmove = move.Notation;
        LOG::LogInfo(message: "No good move found; playing safe " + ourmove); 
      else
    	  // select a random legal move
    	  i = 0;  // coerce integer
    	  i = TIM::current_clock() % legal_moves.length;
    	  ourmove = legal_moves[i];
    	  LOG::LogInfo(message: "Picking random move! " + ourmove); 
      end if;
    end if;
    
    /*
    for each possible in possible_moves
      delete object instance possible;
    end for; 
    */
    
    // play the move
    create event instance e of ActiveGame3:'play move'(move: ourmove) to self;
    ::record_move( move:ourmove, from:" BOT: " );  // record for ground truth
    
    t = TIM::timer_start(event_inst:e, microseconds: 0);
    @endnoparse
  end state;

  state 'playing move'(move: in string) is
    @noparse
    move = param.move;
    
    // play the move
    success = chess::move(game_id: self.id, move: move);
    if success then
    	generate ActiveGame1:'waiting on move' to self;
    else
      LOG::LogFailure(message: "Failed to make move.");
      create event instance e of ActiveGame4:'ready to play' to self;
      t = TIM::timer_start(event_inst: e, microseconds: 100000);  // short delay to slow down endless loop possibility
    end if;
    @endnoparse
  end state;

  state 'claiming victory' is
    @noparse
    r = chess::claimVictory(game_id: self.id);
    @endnoparse
  end state;

end;
