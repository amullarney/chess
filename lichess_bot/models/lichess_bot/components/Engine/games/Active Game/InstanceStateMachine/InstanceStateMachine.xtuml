// BP 7.1.6 content: InstanceStateMachine syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine::games::'Active Game' is

  @state_num(1);
  @dialect("oal");
  state created;

  @state_num(3);
  @dialect("oal");
  state 'game over';

  @state_num(4);
  @dialect("oal");
  state 'our turn';

  @state_num(5);
  @dialect("oal");
  state 'their turn';

  @state_num(6);
  @dialect("oal");
  state 'playing move';

  @state_num(7);
  @dialect("oal");
  state 'claiming victory';

  @event_num(1);
  event 'waiting on move';

  @event_num(2);
  event 'game over'(status: in GameStatus);

  @event_num(3);
  event 'play move'(move: in string);

  @event_num(4);
  event 'ready to play';

  @event_num(5);
  event 'claim victory';

  state model is

    |                    | 'waiting on move'  | 'game over'        | 'play move'        | 'ready to play'    | 'claim victory'    |
    | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ | ------------------ |
    | created            | 'their turn'       | cannot_happen      | cannot_happen      | 'our turn'         | ignore             |
    | 'game over'        | ignore             | cannot_happen      | ignore             | ignore             | ignore             |
    | 'our turn'         | ignore             | 'game over'        | 'playing move'     | 'our turn'         | 'claiming victory' |
    | 'their turn'       | ignore             | 'game over'        | ignore             | 'our turn'         | 'claiming victory' |
    | 'playing move'     | 'their turn'       | 'game over'        | cannot_happen      | ignore             | 'claiming victory' |
    | 'claiming victory' | ignore             | 'game over'        | ignore             | ignore             | ignore             |

  end state model;

  state 'game over'(status: in GameStatus) is
    @noparse
    LOG::LogInfo(message:"Game: " + self.id + ": Game over!");
    r = TIM::timer_cancel(timer_inst_ref: self.claim_victory_timer);
    self.dispose();
    @endnoparse
  end state;

  state 'our turn' is
    @noparse
    LOG::LogInfo(message: "Bot is choosing a move");
    
    // handle takeback proposals
    if (self.color == Color::WHITE and self.game_state.btakeback) or
    	(self.color == Color::BLACK and self.game_state.wtakeback) then
    	self.handle_takeback_proposal();
    end if;
    
    // handle draw offers
    if (self.color == Color::WHITE and self.game_state.bdraw) or
    	(self.color == Color::BLACK and self.game_state.wdraw) then
    	self.handle_draw_offer();
    end if;
    
    played_moves = self.game_state.moves;
    
    i = played_moves.length;
    if (i > 1)
      // we need an update to reflect the change from our last move:
      // some moves invalidated; ground truth of 2 squares changed.
      movestr = played_moves[i-2];  // our last move
      fromsq = ::from_occupied( movestr:movestr );
      tosquare = ::to_square( movestr:movestr );
      select one piece related by fromsq->Piece[R2.'is occupied by'];
    
    	// now dispose of all moves for the piece we last played - not on the start square any more, so all moves are invalid
    	select many moves related by piece->Move[R5];
    	for each move in moves
    	  move.dispose();
    	end for;
    	// Any moves that would have passed through the newly occupied square are now invalid
    	// Consider a Bishop which may have had legal moves to 5 empty squares.
    	// If a Knight's Pawn advances by 2, the last of those is no longer reachable.
    	// Simply eliminate all moves that may be so compromised; they will be rebuilt as needed.
    	select many pieces related by tosquare->Piece[R5.'is reachable by'];
    	for each piece in pieces
    	  piece.clean_moves();
    	end for;
    	// update ground truth of our board representation
    	::record_move( from:fromsq, to:tosquare, recorder:" BOT: " );
    end if;
    
    select one myplayer related by self->Player[R22.'is acting for'];
    select one opponent related by myplayer->Player[R8.'opposes'];
    
    select any opponent_fromocsq from instances of OccupiedSquare where false;  // decl
    select any opponent_tosquare from instances of Square where false;  // decl
    
    i = played_moves.length;
    if (i > 0)
      // now update based on opponent's last move
      movestr = played_moves[i-1];  // most recent from opponent
      opponent_fromocsq = ::from_occupied( movestr:movestr );
      opponent_tosquare = ::to_square( movestr:movestr );
      select one moved_from related by opponent_fromocsq->Square[R1]; // this was potentially a target
      select many moves related by moved_from->Move[R5];  // these moves are no longer interesting as targets
      for each move in moves
        move.dispose();
      end for;
      select many pieces related by opponent_tosquare->Piece[R5.'is reachable by'];
      // any move(s) that may pass through that square are now invalid
      for each piece in pieces
        piece.clean_moves();
      end for;
    end if;
    
    // aquire a list of legal moves to choose from
    legal_moves = ChessLib::legalMoves(fen: ChessLib::movesToFEN(initialFen: self.initial_fen, moves: played_moves));
    nlegals = legal_moves.length;
    
    // clean any move instances that are now no longer legal
    // (consider, for instance, check may vastly reduce legal moves)
    select many potentialmoves related by myplayer->Move[R6.'considers'];
    for each potentialmove in potentialmoves
      select one start related by potentialmove->Piece[R5.'is reachable by']
                                                ->OccupiedSquare[R2.'occupies']->Square[R1];
      select one finish related by potentialmove->Square[R5.'can legally move to'];
      movestr = ::movestr( from:start, to:finish );
      i = 0;
      matched = false;
      while (i < nlegals)  // for each legal move we could play...
        if (movestr == legal_moves[i])
          matched = true;
          break;
        end if;
        i = i + 1;
      end while;
      if (not matched)
        LOG::LogInfo(message: "Disposing non-legal move: " + movestr);
        potentialmove.dispose();
      end if;
    end for;
    
    if (played_moves.length > 0)
      // record the last move - the opponent's - to update our board ground truth
      // Note: this must not be done until all navigation to the played occupied square is done.
      ::record_move( from:opponent_fromocsq, to:opponent_tosquare, recorder:"player: " );
    end if;
    
    // start: a simplistic attempt to choose a move based on high-value target.
    select any chosen_move from instances of Move where false;  // decl
    
    // ensure that a move instance exists for each legal move; create any needed new ones
    i = 0;
    while (i < nlegals)  // for each legal move we could play...
      movestr = legal_moves[i];
      fromsq = ::from_occupied( movestr:movestr );
      tosq = ::to_square( movestr:movestr );
      select one piece related by fromsq->Piece[R2.'is occupied by'];
      select many dests related by piece->Square[R5.'can legally move to'];
      found = false;
      for each dest in dests
        if (dest == tosq)
          found = true;
          break;
        end if;
      end for;
      if (not found)
        create object instance m of Move;
        m.Notation = movestr;  // for debug
        relate piece to tosq across R5 using m;
        relate m to myplayer across R6.'is considered by';
      end if; 
      i = i + 1;
    end while;
    
    // sanity check
    select many moves from instances of Move;
    if (cardinality moves != nlegals)
      LOG::LogInfo(message: "Oops - non matched moves");
    end if;
    
    // now we have bona-fide set of legal Move instances
    // let's pick the 'interesting' ones - those that have a target of value
    
    select many potentialtargets related by opponent->Piece[R7.'owns']
                                                    ->OccupiedSquare[R2.'occupies'];
    select many reachablesquares related by myplayer->Move[R6.'considers']
                                                    ->Square[R5.'can legally move to']
                                                    ->OccupiedSquare[R1];
    targets = potentialtargets & reachablesquares;
    
    // now, targets is the set of reachable squares occupied by opponent pieces
    // choose the highest value target piece
     
    best = 0;
    select any chosen from instances of OccupiedSquare where false;  // decl
    for each target in targets
      select one spec related by target->Piece[R2.'is occupied by']->PieceSpecification[R4.'is specified by'];
      if (spec.Value > best)
        best = spec.Value;
        chosen = target;
      end if;
    end for;
    
    if (not_empty chosen)  // we have a target occupied square with a high-value piece - pick any piece (for now) that can attack
      select any chosen_move related by chosen->Square[R1]->Move[R5];
    else
      // if no targets, may be opening stages of game; look for a move
      if (played_moves.length < 10)  // arbitrary limit on opening move search
    	  select many openermoves from instances of Move;
    	  chosen_move = ::pick_opener_move( moves:openermoves );
      end if;
      if (empty chosen_move)
        select any chosen_move from instances of Move;
      end if;
    end if;
    
    select one piece related by chosen_move->Piece[R5.'is reachable by'];
    select one tosq related by chosen_move->Square[R5.'can legally move to'];
    select one fromsq related by chosen_move->Piece[R5.'is reachable by']
                                            ->OccupiedSquare[R2.'occupies']->Square[R1];
    // play the move - in lichess notation
    ourmove = ::movestr( from:fromsq, to:tosq );
    LOG::LogInfo(message: "BOT selected: " + ourmove); 
    create event instance e of ActiveGame3:'play move'(move: ourmove) to self;
    // zero-timer prevents event prioritization by event-to-self acceleration.
    t = TIM::timer_start(event_inst:e, microseconds: 0);
    @endnoparse
  end state;

  state 'playing move'(move: in string) is
    @noparse
    move = param.move;
    
    // play the move
    LOG::LogInfo( message:"BOT playing move: " + move );
    success = chess::move(game_id: self.id, move: move);
    if success then
    	generate ActiveGame1:'waiting on move' to self;
    else
      LOG::LogFailure(message: "Failed to make move.");
      create event instance e of ActiveGame4:'ready to play' to self;
      t = TIM::timer_start(event_inst: e, microseconds: 100000);  // short delay to slow down endless loop possibility
    end if;
    @endnoparse
  end state;

  state 'claiming victory' is
    @noparse
    r = chess::claimVictory(game_id: self.id);
    @endnoparse
  end state;

end;
