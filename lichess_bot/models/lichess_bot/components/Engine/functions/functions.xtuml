// BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine is

  package functions is
    @dialect("oal");
    @function_num(5);
    function evaluate_response(move: in instance of Move, fen: in string, played_moves: in sequence of string) is
      @noparse
      // reduce the move value by the highest value which may be taken by a response
      potential_move = param.move;
      fen = param.fen;
      played = param.played_moves;

      LOG::LogInfo( message:"Evaluating responses to " + potential_move.Notation);

      select one moved_piece related by potential_move->Piece[R9.'is made by']; // the hypothesized moved piece
      select one fromocsq related by moved_piece->OccupiedSquare[R2.'occupies'];
      select one tosq related by potential_move->Square[R5.'targets'];
      select one movedto related by tosq->OccupiedSquare[R1];  // the move supposedly targetted an opponent piece

      select one opponent related by potential_move->Player[R6.'is playable by']->Player[R8.'opposes'];

      // set up a phoney move sequence as if this potential move were played
      l = played.length;
      as_if_played[l] = potential_move.Notation;
      i = 0;
      while (i < l)
        as_if_played[i] = played[i];
        i = i + 1;
      end while;

      // ensure possible opponent moves are represented
      ::reconcile_moves( fen:fen, moves:as_if_played, player:opponent, trial_move:potential_move );

      // look for vulnerabilities
      select many vulnerables related by opponent->Move[R6.'can play']
                                                  ->Square[R5.'targets']
                                                  ->OccupiedSquare[R1];
      if (empty vulnerables)
        LOG::LogInfo( message:"No risk for this move" );
      end if;

      worst = 0;
      select any piece from instances of Piece where false;
      for each ocsq in vulnerables
        if (ocsq == fromocsq)
          continue;  // if move was made, this would be empty - not vulnerable
        end if;
        if (ocsq == movedto)  // response takes the potentially moved piece
          piece = moved_piece;
        else
          select one piece related by ocsq->Piece[R2.'is occupied by'];
        end if;
        select one spec related by piece->PieceSpecification[R4.'is specified by'];
        select one sq related by ocsq->Square[R1];
        LOG::LogInfo( message:spec.Name + " vulnerable on " + sq.lichess_desig );
        cost = spec.Value;  
        if (cost > worst)
          worst = cost;
        end if;
      end for;
      if (worst != 0)
        LOG::LogInfo( message:potential_move.Notation + " " + STRING::itoa( i: potential_move.Value ) + " reduced by " + STRING::itoa( i:worst  ));
      end if;
      potential_move.Value = potential_move.Value - worst;

      // Now dispose of the responses engendered as a result of hypothesizing this potential move
      select one eval related by potential_move->EvaluatingMove[R11];
      select many response_moves related by eval->PotentialMove[R10.'engenders in response'];
      for each response_move in response_moves
        select one move related by response_move->Move[R11];
        LOG::LogInfo(message: "Disposing of engendered response " + move.Notation);
        move.dispose();
      end for;
      @endnoparse
    end function;

    @dialect("oal");
    @function_num(9);
    function find_covered_squares(player: in instance of Player) return set of instance of OpenSquare is
      @noparse
      // find the set of open squares which opponent pieces can reach
      opponent = param.player;
      select many coveredsquares related by opponent->Move[R6.'can play']->Square[R5.'targets']->OpenSquare[R1];
      select many pieces related by opponent->Piece[R7.'owns'];
      select any spec from instances of PieceSpecification
       where (selected.Name == "Pawn");
      select many pawns related by spec->Piece[R4.'defines properties of'];  // need special treatment
      opponentpawns = pieces & pawns;
      advance = 1;
      if (opponent.Color != Color::WHITE)
        advance = -1;
      end if;
      for each oppawn in opponentpawns
        select one square related by oppawn->OccupiedSquare[R2.'occupies']->Square[R1];
        if (not_empty square)  // may have been taken - no longer occupies a square
          select many possibles from instances of Square
           where (selected.rank == square.rank + advance 
            and (selected.file == square.file + 1 or selected.file == square.file - 1));
          select many opensquares related by possibles->OpenSquare[R1];
          coveredsquares = coveredsquares + opensquares;
        end if;
      end for;
      return coveredsquares;
      @endnoparse
    end function;

    @dialect("oal");
    @function_num(7);
    function find_target_moves(player: in instance of Player) return set of instance of Move is
      @noparse
      // Select those playable moves who target an opposition-held square.

      player = param.player;

      // find only those moves which target opponent-occupied squares:
      // filter all allowed moves (see reconcile_moves()) to those targetting occupied squares;
      // navigate from each occupied square to the supertype square - which is a move target -
      // thence back to the targetting moves. 
      select many target_moves related by player->Move[R6.'can play']  // playable moves
                                                ->Square[R5.'targets']
                                                ->OccupiedSquare[R1]   // targetting opponent-occupied squares
                                                ->Square[R1]
                                                ->Move[R5];

      // debug/instrumentation start
      ctxt = "White";
      if (player.Color == Color::BLACK)
        ctxt = "Black";
      end if;
      if (empty target_moves)
        LOG::LogInfo( message:ctxt + " has no potential targets!" );
      else
      	for each move in target_moves
      	  LOG::LogInfo( message:ctxt + " target move " + move.Notation );
      	end for;
      end if;
      // debug/instrumentation end

      return target_moves;
      @endnoparse
    end function;

    @dialect("oal");
    @function_num(3);
    function init() is
      @noparse
      // load configuration properties
      select any bot from instances of Bot;
      if empty bot then
      	create object instance bot of Bot;
      	bot.config = PROP::loadProperties(file_name:"lichess_bot.properties");
      end if;

      select any opsq from instances of OpenSquare where false; // decl for unused param
      Player::initialize(unused:opsq);
      PieceSpecification::initialize();
      Square::initialize();
      Piece::initialize();
      Openers::initialize();

      // connect to the Lichess API and start listening for events
      send chess::connect(properties: bot.config);

      LOG::LogInfo(message: "Initialization complete");
      @endnoparse
    end function;

    @dialect("oal");
    @function_num(8);
    function play_safe(opponent: in instance of Player) return instance of Move is
      @noparse
      // look for pieces under threat from given opponent
      // explore escape moves for highest (or any) threatened piece.
      opponent = param.opponent;
      select any chosen_move from instances of Move where false; // decl
      select many threats related by opponent->Move[R6.'can play']->Square[R5.'targets']->OccupiedSquare[R1];
      coveredsquares = ::find_covered_squares( player:opponent );
      highestvalue = 0;
      	for each ocsq in threats
      	  select one piece related by ocsq->Piece[R2.'is occupied by'];
      	  select one spec related by piece->PieceSpecification[R4.'is specified by'];
      	  select one sq related by ocsq->Square[R1];
      	  LOG::LogInfo(message:"Seeking safety for " + spec.Name + " on " + sq.lichess_desig);
      	  select many reachables related by piece->Move[R9.'can make']->Square[R5.'targets']->OpenSquare[R1];
      	  refuges = reachables - coveredsquares;
      	  if (not_empty refuges)
      	    if (spec.Value > highestvalue)
      	      highestvalue = spec.Value;
      			  select many tomoves related by refuges->Square[R1]->Move[R5];
      			  select many frommoves related by piece->Move[R9.'can make'];
      			  escapemoves = frommoves & tomoves;
      			  for each escape in escapemoves
      			    select one sq related by escape->Square[R5.'targets'];
      			    LOG::LogInfo(message:"Found possible safe move to " + sq.lichess_desig);
      			    chosen_move = escape; 
      			    break;
      			  end for;
      		  end if;
      		else
      		  LOG::LogInfo( message:"No refuge for " + spec.Name + " on " + sq.lichess_desig );
      		end if;
      	end for;
      	if (empty chosen_move)
      	  LOG::LogInfo(message:"No safe escape move found");
      	end if;
      return chosen_move;
      @endnoparse
    end function;

    @dialect("oal");
    @function_num(6);
    function reconcile_moves(fen: in string, moves: in sequence of string, player: in instance of Player, trial_move: in instance of Move) is
      @noparse
      // match Move instances to allowable moves
      fen = param.fen;
      played_moves = param.moves;
      player = param.player;
      trial = param.trial_move;

      // aquire a list of legal moves to choose from
      legal_moves = ChessLib::legalMoves(fen: ChessLib::movesToFEN(initialFen: fen, moves: played_moves));
      nlegals = legal_moves.length;

      // clean any move instances that are now no longer legal
      // (consider, for instance, check may vastly reduce legal moves)
      count = 0;
      select many potentialmoves related by player->Move[R6.'can play'];
      for each potentialmove in potentialmoves
        select one start related by potentialmove->OccupiedSquare[R5.'vacates']->Square[R1];
        select one finish related by potentialmove->Square[R5.'targets'];
        movestr = ::movestr( from:start, to:finish );
        i = 0;
        matched = false;
        while (i < nlegals)  // for each legal move we could play...
          if (movestr == STRING::substr(s:legal_moves[i], begin:0, end:4));
            matched = true;
            break;
          end if;
          i = i + 1;
        end while;
        if (not matched)
          count = count + 1;
          //LOG::LogInfo(message: "Disposing non-legal move: " + movestr);
          potentialmove.dispose();
        end if;
      end for;
      //LOG::LogInfo( message:"old moves disposed: " + STRING::itoa(i:count));
      // start: a simplistic attempt to choose a move based on high-value target.
      select any chosen_move from instances of Move where false;  // decl

      // ensure that a move instance exists for each legal move; create any needed new ones
      count = 0;
      i = 0;
      while (i < nlegals)  // for each legal move we could play...
        movestr = STRING::substr(s:legal_moves[i], begin:0, end:4);
        fromocsq = ::from_occupied( movestr:movestr );
        tosq = ::to_square( movestr:movestr );
        select one piece related by fromocsq->Piece[R2.'is occupied by'];
        select many dests related by piece->Move[R9]->Square[R5.'targets'];
        found = false;
        for each dest in dests
          if (dest == tosq)
            found = true;
            break;
          end if;
        end for;
        if (not found)
          create object instance m of Move;
          m.Notation = movestr;  // for debug
          create object instance p of PotentialMove;
          relate m to p across R11;
          relate fromocsq to tosq across R5.'targets' using m;
          select many movs related by tosq->Move[R5];
          for each mov in movs
            generate Move3:reactivate() to mov;
          end for;
          relate m to piece across R9;
          relate m to player across R6.'is playable by';
          if (not_empty trial)
            select one tgt related by trial->Square[R5.'targets'];
            if (tgt == tosq)
              select one eval related by trial->EvaluatingMove[R11];
              relate p to eval across R10.'is hypothetical response to';
              LOG::LogInfo(message: trial.Notation + " engendering response " + m.Notation);
            end if;
          else
            LOG::LogInfo(message: "Adding legal move: " + m.Notation);
          end if;
          count = count + 1;
        end if; 
        i = i + 1;
      end while;
      //LOG::LogInfo( message:"new moves added: " + STRING::itoa(i:count));

      // sanity check
      select many moves related by player->Move[R6.'can play'];
      if (cardinality moves != nlegals)
        LOG::LogInfo(message: "Oops - non matched moves");
      end if;
      @endnoparse
    end function;

    //! Each move updates the positions of the pieces on the board, maintaining ground truth.
    @dialect("oal");
    @function_num(4);
    function record_move('from': in instance of OccupiedSquare, 'to': in instance of Square, recorder: in string) is
      @noparse
      start = param.from;  // an occupied square
      dest = param.to;     // a square - occupied? - or not?
      recorder = param.recorder;

      // these 3 lines are debug instrumentation
      select one sq related by start->Square[R1];
      str = ::movestr( from:sq, to:dest );
      LOG::LogInfo( message:"recording move from " + recorder + str );

      select one piece related by start->Piece[R2.'is occupied by'];
      select any ocsq from instances of OccupiedSquare where false;  // decl
      unrelate piece from start across R2.'occupies';
      select one originsq related by start->Square[R1];
      unrelate start from originsq across R1;
      delete object instance start;
      create object instance opsq of OpenSquare;
      relate opsq to originsq across R1;  // the 'move from' square is no longer occupied

      taken = dest.occupant();
      if (not_empty taken)  // the 'move to' square was already occupied - exchange occupants
        select one ocsq related by dest->OccupiedSquare[R1];
        unrelate taken from ocsq across R2.'occupies';
        select one spec related by taken->PieceSpecification[R4.'is specified by'];
        LOG::LogInfo( message:recorder + " captured " + spec.Name + " on " + dest.lichess_desig );
        taken.clean_moves();  // all moves now invalid
        //delete object instance taken; Keep instance for scoring purposes. TBD, may transition in a lifecycle
      else
        select one opsq related by dest->OpenSquare[R1];
        unrelate opsq from dest across R1;
        delete object instance opsq;
        create object instance ocsq of OccupiedSquare;
        relate ocsq to dest across R1;
      end if;
      // check for promotion before finalizing ground truth
      select one spec related by piece->PieceSpecification[R4.'is specified by'];
      if (spec.Name == "Pawn")
       and (dest.rank == 1 or dest.rank == 8) // made to the far rank
        unrelate piece from spec across R4.'is specified by';
        select any qspec from instances of PieceSpecification
         where (selected.Name == "Queen");  // always pick a Queen - why not?!
        relate piece to qspec across R4.'is specified by';
        LOG::LogInfo( message:"PROMOTING ON " + dest.lichess_desig);
      end if;
      relate piece to ocsq across R2.'occupies';
      piece.clean_moves();  // all are now invalid - no longer on start square

      // If destination was an open square, now it is not; any potential move to it
      // must be re-evaluated - b re-creation; if it was occupied, it must have been 
      // by an opponent piece which is now gone, invalidating any moves to it.
      // Note that if this move is an opponent move, ensure there are no outstanding
      // opponent moves still targetting this square as they may be erroneously 
      // picked up by a subsequent move-set selection from the square before
      // any move reconcilation takes place for opponent pieces - that will not
      // happen until response moves are being evaluated.

      select many invalids related by dest->Move[R5]; 
      for each invalid in invalids
        invalid.dispose();
      end for;

      // Castling? - the only time a King can move 2 squares along Rank 1 or 8.
      // lichess does not report the Rook's part in this; record it here to maintain ground truth.

      select one spec related by piece->PieceSpecification[R4.'is specified by'];
      if (spec.Name == "King" 
       and (originsq.rank == 1 or originsq.rank == 8) 
       and dest.rank == originsq.rank 
       and originsq.file == 5)

        select any from from instances of OccupiedSquare where false;
        select any tosq from instances of Square where false;
        rank = originsq.rank;

        if (dest.file == 7)  // King side
          select any sq from instances of Square
           where (selected.rank == rank and selected.file == 8);
          select one from related by sq->OccupiedSquare[R1];
          select any tosq from instances of Square
           where (selected.rank == rank and selected.file == 6);
        elif (dest.file == 3)  // Queen side
          select any sq from instances of Square
           where (selected.rank == rank and selected.file == 1);
          select one from related by sq->OccupiedSquare[R1];
          select any tosq from instances of Square
           where (selected.rank == rank and selected.file == 4);
        end if;

        if (not_empty from and not_empty tosq)
          ::record_move( from:from, to:tosq, recorder:recorder + " O-O " );
        end if;

      end if;
      @endnoparse
    end function;

    @dialect("oal");
    @function_num(1);
    function resign_all() is
      @noparse
      select many games from instances of ActiveGame;
      for each game in games 
      	game.resign();
      end for;
      @endnoparse
    end function;

    @dialect("oal");
    @function_num(2);
    function send_challenge() is
      @noparse
      r = chess::createChallenge(
      	user: "maia1",
      	rated: false,
      	clock_limit: 900,
      	clock_increment: 5,
      	color: Color::RANDOM,
      	variant: Variant::STANDARD,
      	fen: ""
      );
      @endnoparse
    end function;

  end package;

end;
