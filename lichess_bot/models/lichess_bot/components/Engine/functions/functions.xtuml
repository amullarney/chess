// BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine is

  package functions is
    @dialect("oal");
    @function_num(3);
    function init() is
      @noparse
      // load configuration properties
      select any bot from instances of Bot;
      if empty bot then
      	create object instance bot of Bot;
      	bot.config = PROP::loadProperties(file_name:"lichess_bot.properties");
      end if;
      
      Player::initialize();
      PieceSpecification::initialize();
      Square::initialize();
      Piece::initialize();
      Openers::initialize();
      
      // connect to the Lichess API and start listening for events
      send chess::connect(properties: bot.config);
      
      LOG::LogInfo(message: "Initialization complete");
      @endnoparse
    end function;

    //! Each move updates the positions of the pieces on the board, maintaining ground truth.
    @dialect("oal");
    @function_num(4);
    function record_move('from': in instance of OccupiedSquare, 'to': in instance of Square, recorder: in string) is
      @noparse
      start = param.from;  // an occupied square
      dest = param.to;     // a square - occupied? - or not?
      recorder = param.recorder;
      
      // these 3 lines are debug instrumentation
      select one sq related by start->Square[R1];
      str = ::movestr( from:sq, to:dest );
      LOG::LogInfo( message:"recording move from " + recorder + str );
      
      select one piece related by start->Piece[R2.'is occupied by'];
      select any ocsq from instances of OccupiedSquare where false;  // decl
      unrelate piece from start across R2.'occupies';
      select one originsq related by start->Square[R1];
      unrelate start from originsq across R1;
      delete object instance start;
      create object instance opsq of OpenSquare;
      relate opsq to originsq across R1;  // the 'move from' square is no longer occupied
      taken = dest.occupant();
      if (not_empty taken)  // the 'move to' square was already occupied - exchange occupants
        select one ocsq related by dest->OccupiedSquare[R1];
        unrelate taken from ocsq across R2.'occupies';
        taken.clean_moves();
        //delete object instance taken; Keep instance for scoring purposes. TBD, may transition in a lifecycle
      else
        select one opsq related by dest->OpenSquare[R1];
        unrelate opsq from dest across R1;
        delete object instance opsq;
        create object instance ocsq of OccupiedSquare;
        relate ocsq to dest across R1;
      end if;
      relate piece to ocsq across R2.'occupies';
      
      // Castling? - the only time a King can move 2 squares along Rank 1 or 8.
      // lichess does not report the Rook's part in this; record it here to maintain ground truth.
      
      select one spec related by piece->PieceSpecification[R4.'is specified by'];
      if (spec.Name == "King" 
        and (originsq.rank == 1 or originsq.rank == 8) 
        and dest.rank == originsq.rank 
        and originsq.file == 5)
      
        select any from from instances of OccupiedSquare where false;
        select any tosq from instances of Square where false;
        rank = originsq.rank;
        
        if (dest.file == 7)  // King side
          select any sq from instances of Square
           where (selected.rank == rank and selected.file == 8);
          select one from related by sq->OccupiedSquare[R1];
          select any tosq from instances of Square
           where (selected.rank == rank and selected.file == 6);
        elif (dest.file == 3)  // Queen side
          select any sq from instances of Square
           where (selected.rank == rank and selected.file == 1);
          select one from related by sq->OccupiedSquare[R1];
          select any tosq from instances of Square
           where (selected.rank == rank and selected.file == 4);
        end if;
      
        if (not_empty from and not_empty tosq)
          ::record_move( from:from, to:tosq, recorder:recorder + " O-O " );
        end if;
      
      end if;
      @endnoparse
    end function;

    @dialect("oal");
    @function_num(1);
    function resign_all() is
      @noparse
      select many games from instances of ActiveGame;
      for each game in games 
      	game.resign();
      end for;
      @endnoparse
    end function;

    @dialect("oal");
    @function_num(2);
    function send_challenge() is
      @noparse
      r = chess::createChallenge(
      	user: "maia1",
      	rated: false,
      	clock_limit: 900,
      	clock_increment: 5,
      	color: Color::RANDOM,
      	variant: Variant::STANDARD,
      	fen: ""
      );
      @endnoparse
    end function;

  end package;

end;
