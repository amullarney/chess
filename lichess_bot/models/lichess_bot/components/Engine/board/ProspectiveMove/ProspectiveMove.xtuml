// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine::board is

  //! A possible move which is to be evaluated.
  @key_letters("ProspectiveMove");
  @class_num(3);
  class ProspectiveMove is

    //! An encoding of the move as from-to in a 4-character string as used by lichess.
    Notation: string;

    Value: integer;

    //! result of this move does not expose piece to capture.
    Is_safe: boolean;

    Eval_depth: integer;

    Retain: boolean;

    @dialect("oal");
    @operation_num(3);
    operation evaluate_move(fen: in string, moves: in sequence of string) is
      @noparse
      fen = param.fen;
      moves = param.moves;
      
      src = ::from_square( move:self.Notation );
      dest = ::to_square( move:self.Notation );
      
      value = 0;
      /* TBD
      select one start related by self->Square[R2.'starts from'];
      moved_piece = src.occupant();
      select one dest related by self->Square[R2.'ends on'];
      taken = dest.occupant();
      
      if (not_empty taken)  // possible capture of opponent piece
        value = taken.Value;
        LOG::LogInfo(message: "Could take " + taken.Name + " with move " + self.Notation );
        // temporarily, modify board ground truth
        unrelate taken from dest across R1.'occupies';
        relate self to taken across R3.'captures';
        relate moved_piece to dest across R1.'occupies';
      end if;
      self.Value = value;
      */
      
      // prepare to examine responding lookahead legal moves
      n = moves.length;
      next_moves[n] = "";  // allocate
      j = 0;
      while j < n
        next_moves[j] = moves[j];
        j = j + 1;
      end while;
      next_moves[j] = self.Notation;  // hypothesize this move...
      response_moves = ChessLib::legalMoves(fen: ChessLib::movesToFEN(initialFen: fen, moves: next_moves));
      // ...and consider opponent's possible responses
      l = response_moves.length;
      i = 0;
      while (i < l)
        create object instance m of ProspectiveMove;
        m.Eval_depth = self.Eval_depth + 1;
        m.Notation = response_moves[i];
        LOG::LogInfo(message: "Evaluating response move " + response_moves[i]); 
        m.evaluate_response(fen:fen, moves:next_moves);
        i = i + 1;
      end while;
      
      worst = 0;
      select many responses from instances of ProspectiveMove
       where (selected.Eval_depth == self.Eval_depth + 1);
      for each response in responses
        if (response.Value > worst)
          worst = response.Value;
          self.Is_safe = false;
        end if;
        delete object instance response;
      end for;
      
      self.Value = value - worst;
      @endnoparse
    end operation;

    @dialect("oal");
    @operation_num(4);
    operation evaluate_response(fen: in string, moves: in sequence of string) is
      @noparse
      fen = param.fen;
      moves = param.moves;
      
      dest = ::to_square( move:self.Notation );
      taken = dest.occupant();
      
      if (not_empty taken)
        select one spec related by taken->PieceSpecification[R4.'is specified by'];
        self.Value = spec.Value;
        LOG::LogInfo(message: "Could lose " + spec.Name + " to response " + self.Notation ); 
      end if;
      @endnoparse
    end operation;

    @dialect("oal");
    @operation_num(5);
    operation delete() is
      @noparse
      select one osq related by self->OccupiedSquare[R5.'vacates'];
      unrelate self from osq across R5.'vacates';
      select one sq related by self->Square[R6.'ends on'];
      unrelate self from sq across R6.'ends on';
      select one int related by self->Interaction[R8.'presents'];
      if (not_empty int)
        int.delete();
      end if;
      delete object instance self;
      @endnoparse
    end operation;

  end class;

end;
