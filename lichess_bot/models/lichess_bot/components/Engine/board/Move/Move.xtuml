// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine::board is

  @key_letters("Move");
  @class_num(3);
  class Move is

    Notation: string;

    Value: integer;

    @dialect("oal");
    @operation_num(1);
    operation from_square() return instance of Square is
      @noparse
      select one ocsq related by self->Piece[R5.'is reachable by']->OccupiedSquare[R2.'occupies'];
      return ocsq;
      @endnoparse
    end operation;

    @dialect("oal");
    @operation_num(2);
    class operation to_square(move: in string) return instance of Square is
      @noparse
      str = param.move;
      move_to = STRING::substr(s:str, begin:2, end:4);
      select any square from instances of Square
       where (selected.lichess_desig == move_to);
      return square;
      @endnoparse
    end operation;

    @dialect("oal");
    @operation_num(3);
    operation evaluate_move(fen: in string, moves: in sequence of string) is
      @noparse
      fen = param.fen;
      moves = param.moves;
      
      src = ::from_square( movestr:self.Notation );
      dest = ::to_square( movestr:self.Notation );
      
      select one moved_piece related by src->Piece[R2.'is occupied by'];
      taken = dest.occupant();
      
      value = 0;
      if (not_empty taken)  // possible capture of opponent piece
        select one spec related by taken->PieceSpecification[R4.'is specified by'];
        value = spec.Value;
        LOG::LogInfo(message: "Could take " + spec.Name + " with move " + self.Notation ); 
      end if;
      self.Value = value;
      
      // prepare to examine responding lookahead legal moves
      n = moves.length;
      next_moves[n] = "";  // allocate
      j = 0;
      while j < n
        next_moves[j] = moves[j];
        j = j + 1;
      end while;
      next_moves[j] = self.Notation;  // hypothesize this move...
      response_moves = ChessLib::legalMoves(fen: ChessLib::movesToFEN(initialFen: fen, moves: next_moves));
      // ...and consider opponent's possible responses
      l = response_moves.length;
      i = 0;
      while (i < l)
        create object instance m of Move;
        m.Notation = response_moves[i];
        LOG::LogInfo(message: "Evaluating response move " + response_moves[i]); 
        m.evaluate_response(fen:fen, moves:next_moves);
        i = i + 1;
      end while;
      
      worst = 0;
      select many responses from instances of Move;
      for each response in responses
        if (response.Value > worst)
          worst = response.Value;
        end if;
        delete object instance response;
      end for;
      
      self.Value = value - worst;
      @endnoparse
    end operation;

    @dialect("oal");
    @operation_num(4);
    operation evaluate_response(fen: in string, moves: in sequence of string) is
      @noparse
      fen = param.fen;
      moves = param.moves;
      
      dest = Move::to_square( move:self.Notation );
      taken = dest.occupant();
      
      if (not_empty taken)
        select one spec related by taken->PieceSpecification[R4.'is specified by'];
        self.Value = spec.Value;
        LOG::LogInfo(message: "Could lose " + spec.Name + " to response " + self.Notation ); 
      end if;
      @endnoparse
    end operation;

  end class;

end;
