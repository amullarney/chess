// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine::board is

  @key_letters("Move");
  @class_num(3);
  class Move is

    Notation: string;

    Value: integer;

    //! result of this move does not expose piece to capture.
    Is_safe: boolean;

    Eval_depth: integer;

    @dialect("oal");
    @operation_num(1);
    class operation from_square(move: in string) return instance of Square is
      @noparse
      str = param.move;
      move_from = STRING::substr(s:str, begin:0, end:2);
      select any square from instances of Square
       where (selected.lichess_desig == move_from);
      return square;
      @endnoparse
    end operation;

    @dialect("oal");
    @operation_num(2);
    class operation to_square(move: in string) return instance of Square is
      @noparse
      str = param.move;
      move_to = STRING::substr(s:str, begin:2, end:4);
      select any square from instances of Square
       where (selected.lichess_desig == move_to);
      return square;
      @endnoparse
    end operation;

    @dialect("oal");
    @operation_num(3);
    operation evaluate_move(fen: in string, moves: in sequence of string) is
      @noparse
      fen = param.fen;
      moves = param.moves;
      
      src = Move::from_square( move:self.Notation );
      dest = Move::to_square( move:self.Notation );
      
      moved_piece = src.occupant();
      taken = dest.occupant();
      
      value = 0;
      if (not_empty taken)  // possible capture of opponent piece
        value = taken.Value;
        LOG::LogInfo(message: "Could take " + taken.Name + " with move " + self.Notation ); 
      end if;
      self.Value = value;
      
      // prepare to examine responding lookahead legal moves
      n = moves.length;
      next_moves[n] = "";  // allocate
      j = 0;
      while j < n
        next_moves[j] = moves[j];
        j = j + 1;
      end while;
      next_moves[j] = self.Notation;  // hypothesize this move...
      nextfen = ChessLib::movesToFEN( initialFen: fen, moves: next_moves );
      response_moves = ChessLib::legalMoves(fen: ChessLib::movesToFEN(initialFen: nextfen, moves: next_moves));
      // ...and consider opponent's possible responses
      l = response_moves.length;
      i = 0;
      while (i < l)
        create object instance m of Move;
        m.Eval_depth = self.Eval_depth + 1;
        m.Notation = response_moves[i];
        LOG::LogInfo(message: "Evaluating response move " + response_moves[i]); 
        m.evaluate_response(fen:nextfen, moves:moves);
        i = i + 1;
      end while;
      
      worst = 0;
      select many responses from instances of Move
       where (selected.Eval_depth == self.Eval_depth + 1);
      for each response in responses
        if (response.Value > worst)
          worst = response.Value;
          self.Is_safe = false;
        end if;
        delete object instance response;
      end for;
      
      self.Value = value - worst;
      @endnoparse
    end operation;

    @dialect("oal");
    @operation_num(4);
    operation evaluate_response(fen: in string, moves: in sequence of string) is
      @noparse
      fen = param.fen;
      moves = param.moves;
      
      //src = Move::from_square( move:self.Notation );
      dest = Move::to_square( move:self.Notation );
      
      //moved_piece = src.occupant();
      taken = dest.occupant();
      
      if (not_empty taken)  // possible capture of opponent piece
        self.Value = taken.Value;
        LOG::LogInfo(message: "Could take " + taken.Name + " with response " + self.Notation ); 
      end if;
      @endnoparse
    end operation;

  end class;

end;
