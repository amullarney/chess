// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within lichess_bot::components::Engine::board is

  @key_letters("Move");
  @class_num(3);
  class Move is

    Notation: string;

    Value: integer;

    //! result of this move does not expose piece to capture.
    Is_safe: boolean;

    @dialect("oal");
    @operation_num(1);
    class operation from_square(move: in string) return instance of Square is
      @noparse
      str = param.move;
      move_from = STRING::substr(s:str, begin:0, end:2);
      select any square from instances of Square
       where (selected.lichess_desig == move_from);
      return square;
      @endnoparse
    end operation;

    @dialect("oal");
    @operation_num(2);
    class operation to_square(move: in string) return instance of Square is
      @noparse
      str = param.move;
      move_to = STRING::substr(s:str, begin:2, end:4);
      select any square from instances of Square
       where (selected.lichess_desig == move_to);
      return square;
      @endnoparse
    end operation;

    @dialect("oal");
    @operation_num(3);
    operation evaluate(fen: in string, moves: in sequence of string) is
      @noparse
      fen = param.fen;
      moves = param.moves;
      
      src = Move::from_square( move:self.Notation );
      dest = Move::to_square( move:self.Notation );
      
      moved_piece = src.occupant();
      taken = dest.occupant();
      
      value = 0;
      if (not_empty taken)  // captured opponent piece
        value = taken.Value;
        LOG::LogInfo(message: "Could take " + taken.Name + " with move " + self.Notation ); 
      end if;
      self.Value = value;
      
      // prepare to examine opponent lookahead legal moves
      n = moves.length;
      next_moves[n] = "";
      j = 0;
      while j < n
        next_moves[j] = moves[j];
        j = j + 1;
      end while;
      next_moves[j] = self.Notation;
      f = ChessLib::movesToFEN( initialFen: fen, moves: next_moves );
      response_moves = ChessLib::legalMoves(fen: ChessLib::movesToFEN(initialFen: fen, moves: next_moves));
      // now considering opponent's possible responses to this move
      l = response_moves.length;
      k = 0;
      while (k < l)
        response = response_moves[k];
        opponent_dest = Move::to_square( move:response );
      /*
        move_to = STRING::substr(s:response, begin:2, end:4);
        select any opponent_dest from instances of Square
         where (selected.lichess_desig == move_to);
      */  
        if (opponent_dest == dest)  // losing the moved_piece in a possible opponent response?
          self.Is_safe = false;
          value = value - moved_piece.Value;
          if (value < self.Value)
            self.Value = value;
          end if;
          if (value < 0)
            LOG::LogInfo(message: self.Notation + " is vulnerable to response " + response);
            break;  // this move presents a loss vulnerability - stop considering it
          end if;
        end if;
        k = k + 1;
      end while;
      @endnoparse
    end operation;

  end class;

end;
